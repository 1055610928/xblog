---
title: 1. 浏览器组成与css
urlname: ydce2n
date: '2021-06-13 12:48:25 +0800'
tags: []
categories: []
---

#### 浏览器的组成

- 组成：
  - **地址栏**：用于输入网站地址，通过识别地址信息跳转到对应网站
  - **菜单栏**：包含设置内容和常用快捷操作，用户可自定义设置内容
  - **标签栏**：包含一个或多个窗口，窗口的内容互不干扰，独立运行
  - **窗口栏**：显示当前网站地址的访问内容，可为用户提供各种交互操作
  - **状态栏**：用于实时显示当前操作和下载 Web 页面的进度情况
- 浏览器历史
  - 1993 年，NCSA 组织 (国家超级计算机应用中心) 发布了 Mosaic(马赛克)浏览器
  - `1994年`，`网景公司`发布了**Navigator 浏览器**
  - `1995年`，`微软公司`发布了**IExplorer 浏览器**，并掀起了`浏览器之战`
  - `1996年`，Navigator 浏览器的市场份额达到`86%`，微软公司开始将 IExplorer 浏览器整合到`Windows操作系统`中
  - `1996年`，`ASA公司`发布了**Opera 浏览器**
  - `1998年`，网景公司启动其开源产品，开始推出`Mozilla`
  - `2001年`，为人诟病的`IExplorer 6`发布，这货霸占国内市场十多年
  - `2002年`，`网景公司`发布了**Firefox 浏览器**
  - `2003年`，`苹果公司`发布了**Safari 浏览器**
  - `2004年`，IExplorer 浏览器的市场份额达到了历史顶峰`92%`，自此以后其市场份额开始下滑
  - `2006年`，`Firefox 3`的发布创下了吉尼斯世界纪录，一天 800 万下载量
  - `2008年`，`谷歌公司`发布了**Chrome 浏览器**
- 渲染引擎
  - 渲染引擎又名浏览器内核，指负责对网页语法解析并渲染成一张可视化页面的解析器，它是浏览器最核心最重要的部位，不同内核对网页语法的解析也有不同，因此同一网页语法在不同内核的浏览器中的渲染效果也可能不同，这就是常说的**浏览器差异性**
  - **Google Chrome**：Webkit(前期)、Blink(后期)
  - **Apple Safari**：Webkit
  - **Mozilla Firefox**：Gecko
  - **ASA Opera**：Presto(前期)、Blink(后期)
  - **Microsoft IExplorer**：Trident
  - **Microsoft Edge**：Trident(前期)、Blink(后期)
- **Blink 内核**：由谷歌公司和欧朋公司合作自研的内核，同时谷歌公司也将其作为开源内核架构`Chromium`的一部分发布，在`Chrome 28+`和`Opear 15+`中被使用。
- **Webkit 内核**：由苹果公司自研的内核，同时也是`Blink内核`的原型，在`Chrome 1 ~ 28`和`Safari 1+`中被使用。
- **Gecko 内核**：由网景公司自研的内核，先期在`Navigator`中使用，后期推广到`Firefox`上，在`Firefox 1+`中被使用。
- **Presto 内核**：由欧朋公司自研的内核，其渲染性能达到极致但牺牲了兼容性，目前已经废弃，在`Opear 7 ~ 14`中被使用。
- **Trident 内核**：由微软公司自研的内核，由于其被包含在全世界使用率最高的`Windows操作系统`中，导致十多年时间里一直称霸浏览器内核界，在`IExplorer 4+`中被使用

#### 渲染过程

- 要了解浏览器页面的渲染过程，首先得知道`关键渲染路径`。**关键渲染路径**指浏览器从最初接收请求得到 HTML、CSS、JS 等资源，然后解析、构建、渲染、布局、绘制、合成，到最后呈现在用户眼前界面的整个过程。
- 解析
  - 将 html 文件转换为 DOM 树
  - 将 css 文件转换为 CSSOM 树
  - 将 DOM 树和 CSSOM 树合并生成渲染树
- 绘制图层
  - 根据渲染树生成布局渲染树(回流)
  - 根据布局渲染树生成绘制渲染树(重绘)
- 合成图层
  - 根据绘制渲染树合成图层显示在屏幕上

#### 解析文件

- 浏览器通过`HTML解析器`将 HTML 解析成`DOM树`结构。HTML 文档中所有内容皆为节点，各节点间拥有层级关系，彼此相连，构成 DOM 树。构建`DOM树`的过程：读取 HTML 文档的**字节**(Bytes)，将字节转换成**字符**(Chars)，依据字符确定**标签**(Tokens)，将标签转换成**节点**(Nodes)，以节点为基准构建**DOM 树**
- 构建`CSSOM树`的过程：读取 CSS 文档的**字节**(Bytes)，将字节转换成**字符**(Chars)，依据字符确定**标签**(Tokens)，将标签转换成**节点**(Nodes)，以节点为基准构建**CSSOM 树**
- 当`HTML解析器`遇到`<script>`时会立即阻塞 DOM 树的构建，将控制权移交给浏览器的`JS引擎`，等到`JS引擎`运行完毕，浏览器才会从中断的地方恢复 DOM 树的构建。`<script>`的脚本加载完毕，`JS引擎`通过`DOM API`和`CSSOM API`操作 DOM 树和 CSSOM 树。

#### 回流和重绘

- **回流**：几何属性需改变的渲染
  - 比如修改了 width,或者 height 等
  - **回流**又名**重排**，指`几何属性`需改变的渲染。但感觉回流这个词较高大上，后续统称回流吧。
    可理解成，将整个网页填白，对内容重新渲染一次。只不过以人眼的感官速度去看浏览器回流是不会有任何变化的，若你拥有`闪电侠`的感官速度去看浏览器回流(`实质是将时间调慢`)，就会发现每次回流都会将页面清空，再从左上角第一个像素点从左到右从上到下这样一点一点渲染，直至右下角最后一个像素点。每次回流都会呈现该过程，只是感受不到而已。
    渲染树的节点发生改变，影响了该节点的几何属性，导致该节点位置发生变化，此时就会触发浏览器回流并重新生成渲染树。回流意味着节点的几何属性改变，需重新计算并生成渲染树，导致渲染树的全部或部分发生变化。
- 重绘：
  - 更改外观属性而不影响集合属性的渲染
  - **重绘**指更改`外观属性`而不影响`几何属性`的渲染。
- 当生成渲染树后，至少会渲染一次。在后续交互过程中，还会不断地重新渲染。这时只会`回流重绘`或`只有重绘`。因此引出一个定向法则：**回流必定引发重绘，重绘不一定引发回流**
- **几何属性**：包括布局、尺寸等可用数学几何衡量的属性
  - 布局：`display`、`float`、`position`、`list`、`table`、`flex`、`columns`、`grid`
  - 尺寸：`margin`、`padding`、`border`、`width`、`height`
- **外观属性**：包括界面、文字等可用状态向量描述的属性
  - 界面：`appearance`、`outline`、`background`、`mask`、`box-shadow`、`box-reflect`、`filter`、`opacity`、`clip`
  - 文字：`text`、`font`、`word`

#### 性能优化

- **回流重绘**在操作节点样式时频繁出现，同时也存在很大程度上的性能问题。`回流成本比重绘成本高得多`，一个节点的回流很有可能导致子节点、兄弟节点或祖先节点的回流。在一些高性能电脑上也许无什么影响，但回流发生在手机上(`明摆说某些安卓手机`)，就会`减缓加载速度`和`增加电量消耗`
- **回流必定引发重绘，重绘不一定引发回流**
- **如何减少和避免回流重绘？**
  - 使用 visibility:hidden 替换 display:none
    - 占位表现
      - `display:none`不占据空间
      - `visibility:hidden`占据空间
    - 触发影响
      - `display:none`触发回流重绘
      - `visibility:hidden`触发重绘
    - 过渡影响
      - `display:none`影响过渡不影响动画
      - `visibility:hidden`不影响过渡不影响动画
    - 株连效果
      - `display:none`后自身及其子节点全都不可见
      - `visibility:hidden` 后自身及其子节点全都不可见但可声明子节点`visibility:visible`单独显示
- **使用 transform 代替 top**
  - `top`是几何属性，操作`top`会改变节点位置从而引发回流，使用`transform:translate3d(x,0,0)`代替`top`，只会引发图层重绘，还会间接启动 GPU 加速
- **避免使用 Table 布局**
  - `牵一发而动全身`用在 Table 布局身上就很适合了，可能很小的一个改动就会造成整个`<table>`回流
  - 通常可用`<ul>`、`<li>`和`<span>`等标签取代`<table>`系列标签生成表格
- **避免层级过多**
  - 浏览器的`CSS解析器`解析`css文件`时，对 CSS 规则是从右到左匹配查找，样式层级过多会影响回流重绘效率，建议保持 CSS 规则在`3层`左右
- **避免节点属性值放在循环里当成循环变量**

```javascript
for (let i = 0; i < 10000; i++) {
  const top = document.getElementById("css").style.top;
  console.log(top);
}
```

- 每次循环操作 DOM 都会发生回流，应该在循环外使用变量保存一些不会变化的 DOM 映射值

```javascript
const top = document.getElementById("css").style.top;
for (let i = 0; i < 10000; i++) {
  console.log(top);
}
```

#### 盒子模型

- **盒模型**由以下属性组成，由外到内用公式表示就是：`box = margin + border + padding + content`
  - **margin**：边距，外部透明区域，负责隔离相邻盒子
  - **border**：边框，内部着色区域，负责隔离边距和填充，包含`width`、`style`、`color`三个扩展属性
  - **padding**：填充，内部着色区域，负责扩展盒子内部尺寸
  - **content**：内容，以`文本`或`节点`存在的占用位置
- 类型
  - 由于历史原因，盒模型分化成两种类型，分别是**标准盒模型**和**怪异盒模型**。
  - 所以 CSS3 里提供一个属性用于声明盒模型的类型，它就是`box-sizing`。
    - **content-box**：标准盒模型(`默认`)
    - **border-box**：怪异盒模型
  - 怪异盒模型
    - **怪异盒模型**又名`IE盒子模型`，是`IExplore`制定的标准，由`margin + content`组成
    - 在 IExplore 中，若 HTML 文档缺失`<!doctype html>`声明则会触发怪异盒模型
- 块格式化上下文
  - BFC 是页面上一个独立且隔离的渲染区域，容器里的子节点不会在布局上影响到外面的节点，反之亦然。
  - 规则
    - 节点在垂直方向上按顺序排列
    - 节点垂直方向距离由`margin`决定，相邻节点的`margin`会发生重叠，以最大`margin`为合并值
    - 节点的`margin-left/right`与父节点的`左边/右边`相接触，即使处于浮动也如此，除非自行形成 BFC
    - BFC 是一个隔离且不受外界影响的独立容器
    - BFC 不会与同级浮动区域重叠
    - 计算 BFC 高度时其浮动子节点也参与计算
  - 成因
    - 根节点：`html`
    - 非溢出可见节点：`overflow:!visible`
    - 浮动节点：`float:left/right`
    - 绝对定位节点：`position:absolute/fixed`
    - 被定义成块级的非块级节点：`display:inline-block/table-cell/table-caption/flex/inline-flex/grid/inline-grid`
    - 父节点与正常文档流的子节点(非浮动)自动形成 BFC
  - 场景
    - 清除浮动
    - 已知宽度水平居中
    - 防止浮动节点被覆盖
    - 防止垂直 margin 合并
- 权重
  - **10000**：`!important`
  - **1000**：`内联样式`、`外联样式`
  - **100**：`ID选择器`
  - **10**：`类选择器`、`伪类选择器`、`属性选择器`
  - **1**：`标签选择器`、`伪元素选择器`
  - **0**：`通配选择器`、`后代选择器`、`兄弟选择器`
- 微观权重
  - **1,0,0,0,0**：`!important`
  - **0,1,0,0,0**：`内联样式`、`外联样式`
  - **0,0,1,0,0**：`ID选择器`
  - **0,0,0,1,0**：`类选择器`、`伪类选择器`、`属性选择器`
  - **0,0,0,0,1**：`标签选择器`、`伪元素选择器`
  - **0,0,0,0,0**：`通配选择器`、`后代选择器`、`兄弟选择器`
  - !important > 内联样式 = 外联样式 > ID 选择器 > 类选择器 = 伪类选择器 = 属性选择器 > 标签选择器 = 伪元素选择器 > 通配选择器 = 后代选择器 = 兄弟选择器

#### 选择器

- 层次选择器  
  | 选择器 | 别名 | 说明 | 版本 |
  | --- | --- | --- | --- |
  | `elemP elemC` | `后代选择器` | 元素的`后代元素` | 1 |
  | `elemP>elemC` | `子代选择器` | 元素的`子代元素` | 2 |
  | `elem1+elem2` | `相邻同胞选择器` | 元素相邻的`同胞元素` | 2 |
  | `elem1~elem2` | `通用同胞选择器` | 元素后面的`同胞元素` | 3 |

- 集合选择器  
  | 选择器 | 别名 | 说明 | 版本 |
  | --- | --- | --- | --- |
  | `elem1,elem2` | `并集选择器` | 多个指定的`元素` | 1 |
  | `elem.class` | `交集选择器` | 指定类名的`元素` | 1 |

- +和~
  - `+/~`都是作用于当前节点后的同胞节点，但两者有一个明显的区别，`+`是针对紧随该节点的节点，而`~`是针对后面所有的节点，包括紧随该节点的节点。
